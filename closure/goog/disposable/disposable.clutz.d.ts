//!! generated by clutz.
// Generated from disposable/disposable.js
declare namespace ಠ_ಠ.clutz.goog {
  /**
   * Class that provides the basic implementation for disposable objects. If your
   * class holds references or resources that can't be collected by standard GC,
   * it should extend this class or implement the disposable interface (defined
   * in goog.disposable.IDisposable). See description of
   * goog.disposable.IDisposable for examples of cleanup.
   */
  class Disposable implements ಠ_ಠ.clutz.goog.disposable.IDisposable {
    private noStructuralTyping_goog_Disposable : any;
    /**
     * If monitoring the goog.Disposable instances is enabled, stores the creation
     * stack trace of the Disposable instance.
     */
    creationStack ? : string ;
    /**
     * Invokes a callback function when this object is disposed. Callbacks are
     * invoked in the order in which they were added. If a callback is added to
     * an already disposed Disposable, it will be called immediately.
     * @param callback The callback function.
     * @param opt_scope An optional scope to call the callback in.
     */
    addOnDisposeCallback < T = any > (callback : (this : T ) => any , opt_scope ? : T ) : void ;
    /**
     * Disposes of the object. If the object hasn't already been disposed of, calls
     * {@link #disposeInternal}. Classes that extend `goog.Disposable` should
     * override {@link #disposeInternal} in order to cleanup references, resources
     * and other disposable objects. Reentrant.
     */
    dispose ( ) : void ;
    /**
     * Performs appropriate cleanup. See description of goog.disposable.IDisposable
     * for examples. Classes that extend `goog.Disposable` should override this
     * method. Not reentrant. To avoid calling it twice, it must only be called from
     * the subclass' `disposeInternal` method. Everywhere else the public `dispose`
     * method must be used. For example:
     *
     * <pre>
     * mypackage.MyClass = function() {
     * mypackage.MyClass.base(this, 'constructor');
     * // Constructor logic specific to MyClass.
     * ...
     * };
     * goog.inherits(mypackage.MyClass, goog.Disposable);
     *
     * mypackage.MyClass.prototype.disposeInternal = function() {
     * // Dispose logic specific to MyClass.
     * ...
     * // Call superclass's disposeInternal at the end of the subclass's, like
     * // in C++, to avoid hard-to-catch issues.
     * mypackage.MyClass.base(this, 'disposeInternal');
     * };
     * </pre>
     */
    protected disposeInternal ( ) : void ;
    getDisposed ( ) : boolean ;
    isDisposed ( ) : boolean ;
    /**
     * Associates a disposable object with this object so that they will be disposed
     * together.
     * @param disposable that will be disposed when this object is disposed.
     */
    registerDisposable (disposable : ಠ_ಠ.clutz.goog.disposable.IDisposable | null ) : void ;
    static INCLUDE_STACK_ON_CREATION : boolean ;
    static MONITORING_MODE : number ;
    static clearUndisposedObjects ( ) : void ;
    static getUndisposedObjects ( ) : ಠ_ಠ.clutz.goog.Disposable [] ;
    /**
     * Returns True if we can verify the object is disposed.
     * Calls `isDisposed` on the argument if it supports it.  If obj
     * is not an object with an isDisposed() method, return false.
     * @param obj The object to investigate.
     */
    static isDisposed (obj : any ) : boolean ;
  }
}
// Generated from disposable/disposable.js
declare namespace ಠ_ಠ.clutz.goog.Disposable {
  enum MonitoringMode {
    INTERACTIVE = 2.0 ,
    OFF = 0.0 ,
    PERMANENT = 1.0 ,
  }
}
declare module 'goog:goog.Disposable' {
  import Disposable = ಠ_ಠ.clutz.goog.Disposable;
  export default Disposable;
}
