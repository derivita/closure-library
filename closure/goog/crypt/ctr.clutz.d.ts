//!! generated by clutz.
// Generated from crypt/ctr.js
declare namespace ಠ_ಠ.clutz.goog.crypt {
  /**
   * Implementation of Ctr mode for block ciphers.  See
   * http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation
   * #Cipher-block_chaining_.28Ctr.29. for an overview, and
   * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
   * for the spec.
   */
  class Ctr {
    private noStructuralTyping_goog_crypt_Ctr : any;
    /**
     * Implementation of Ctr mode for block ciphers.  See
     * http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation
     * #Cipher-block_chaining_.28Ctr.29. for an overview, and
     * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
     * for the spec.
     * @param cipher The block cipher to use.
     */
    constructor (cipher : ಠ_ಠ.clutz.goog.crypt.BlockCipher ) ;
    /**
     * Decrypts a message. In CTR, this is the same as encrypting.
     * @param cipherText Message to decrypt. The length does not have to be a multiple of the blocksize.
     * @param initialVector Initial vector for the Ctr mode. An array of bytes with the same length as the block size.
     */
    decrypt (a : number [] | Uint8Array , b : number [] | Uint8Array ) : number [] ;
    /**
     * Encrypts a message.
     * @param plainText Message to encrypt. An array of bytes. The length does not have to be a multiple of the blocksize.
     * @param initialVector Initial vector for the Ctr mode. An array of bytes with the same length as the block size, that should be not reused when using the same key.
     */
    encrypt (plainText : number [] | Uint8Array , initialVector : number [] | Uint8Array ) : number [] ;
  }
}
declare module 'goog:goog.crypt.Ctr' {
  import Ctr = ಠ_ಠ.clutz.goog.crypt.Ctr;
  export default Ctr;
}
