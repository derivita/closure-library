//!! generated by clutz.
// Generated from crypt/blobhasher.js
declare namespace ಠ_ಠ.clutz.goog.crypt {
  /**
   * Construct the hash computer.
   */
  class BlobHasher extends ಠ_ಠ.clutz.goog.events.EventTarget {
    private noStructuralTyping_goog_crypt_BlobHasher : any;
    /**
     * Construct the hash computer.
     * @param hashFn The hash function to use.
     * @param opt_blockSize Processing block size.
     */
    constructor (hashFn : ಠ_ಠ.clutz.goog.crypt.Hash , opt_blockSize ? : number ) ;
    abort ( ) : void ;
    getBytesProcessed ( ) : number ;
    getHash ( ) : number [] | null ;
    /**
     * Start the hash computation.
     * @param blob The blob of data to compute the hash for.
     */
    hash (blob : Blob ) : void ;
    /**
     * Sets the maximum number of bytes to hash or Infinity for no limit. Can be
     * called before hash() to throttle the hash computation. The hash computation
     * can then be continued by repeatedly calling setHashingLimit() with greater
     * byte offsets. This is useful if you don't need the hash until some time in
     * the future, for example when uploading a file and you don't need the hash
     * until the transfer is complete.
     * @param byteOffset The byte offset to compute the hash up to. Should be a non-negative integer or Infinity for no limit. Negative values are not allowed.
     */
    setHashingLimit (byteOffset : number ) : void ;
  }
}
declare module 'goog:goog.crypt.BlobHasher' {
  import BlobHasher = ಠ_ಠ.clutz.goog.crypt.BlobHasher;
  export default BlobHasher;
}
// Generated from crypt/blobhasher.js
declare namespace ಠ_ಠ.clutz.goog.crypt.BlobHasher {
  /**
   * Event names for hash computation events
   */
  /**
   * Event names for hash computation events
   */
  enum EventType {
    ABORT = 'abort' ,
    COMPLETE = 'complete' ,
    ERROR = 'error' ,
    PROGRESS = 'progress' ,
    STARTED = 'started' ,
    THROTTLED = 'throttled' ,
  }
}
declare module 'goog:goog.crypt.BlobHasher.EventType' {
  import EventType = ಠ_ಠ.clutz.goog.crypt.BlobHasher.EventType;
  export default EventType;
}
