//!! generated by clutz.
// Generated from proto2/textformatserializer.js
declare namespace ಠ_ಠ.clutz.goog.proto2 {
  /**
   * TextFormatSerializer, a serializer which turns Messages into the human
   * readable text format.
   */
  class TextFormatSerializer extends ಠ_ಠ.clutz.goog.proto2.Serializer {
    private noStructuralTyping_goog_proto2_TextFormatSerializer : any;
    /**
     * TextFormatSerializer, a serializer which turns Messages into the human
     * readable text format.
     * @param opt_ignoreMissingFields If true, then fields that cannot be found on the proto when parsing the text format will be ignored.
     * @param opt_useEnumValues If true, serialization code for enums will use enum integer values instead of human-readable symbolic names.
     */
    constructor (opt_ignoreMissingFields ? : boolean , opt_useEnumValues ? : boolean ) ;
    /**
     * Deserializes a message from text format and places the data in the message.
     * @param message The message in which to place the information.
     * @param data The text format data.
     */
    deserializeTo (message : ಠ_ಠ.clutz.goog.proto2.Message | null , data : any ) : string | null ;
    /**
     * Serializes a message to a string.
     * @param message The message to be serialized.
     */
    serialize (message : ಠ_ಠ.clutz.goog.proto2.Message | null ) : string ;
  }
}
// Generated from proto2/textformatserializer.js
declare namespace ಠ_ಠ.clutz.goog.proto2.TextFormatSerializer {
  class Parser {
    private noStructuralTyping_goog_proto2_TextFormatSerializer_Parser : any;
    getError ( ) : string | null ;
    /**
     * Parses the given data, filling the message as it goes.
     * @param message The message to fill.
     * @param data The text format data.
     * @param opt_ignoreMissingFields If true, fields missing in the proto will be ignored.
     */
    parse (message : ಠ_ಠ.clutz.goog.proto2.Message | null , data : string , opt_ignoreMissingFields ? : boolean ) : boolean ;
  }
  class Printer_ {
    private noStructuralTyping_goog_proto2_TextFormatSerializer_Printer_ : any;
    /**
     * Appends the given value to the printer.
     * @param value The value to append.
     */
    append (value : any ) : void ;
    appendLine ( ) : void ;
    dedent ( ) : void ;
    indent ( ) : void ;
    toString ( ) : string ;
  }
  class Tokenizer_ {
    private noStructuralTyping_goog_proto2_TextFormatSerializer_Tokenizer_ : any;
    getCurrent ( ) : ಠ_ಠ.clutz.goog.proto2.TextFormatSerializer.Tokenizer_.Token ;
    /**
     * Advances to the next token.
     */
    next ( ) : boolean ;
  }
}
// Generated from proto2/textformatserializer.js
declare namespace ಠ_ಠ.clutz.goog.proto2.TextFormatSerializer.Tokenizer_ {
  type Token = { type : ಠ_ಠ.clutz.goog.proto2.TextFormatSerializer.Tokenizer_.TokenTypes , value : string | null } ;
  type TokenTypes = RegExp &{clutzEnumBrand: never} ;
  let TokenTypes : {
    BAD : TokenTypes ,
    CLOSE_BRACE : TokenTypes ,
    CLOSE_LIST : TokenTypes ,
    CLOSE_TAG : TokenTypes ,
    COLON : TokenTypes ,
    COMMA : TokenTypes ,
    COMMENT : TokenTypes ,
    END : TokenTypes ,
    IDENTIFIER : TokenTypes ,
    NUMBER : TokenTypes ,
    OPEN_BRACE : TokenTypes ,
    OPEN_LIST : TokenTypes ,
    OPEN_TAG : TokenTypes ,
    SEMI : TokenTypes ,
    STRING : TokenTypes ,
    WHITESPACE : TokenTypes ,
  };
}
declare module 'goog:goog.proto2.TextFormatSerializer' {
  import TextFormatSerializer = ಠ_ಠ.clutz.goog.proto2.TextFormatSerializer;
  export default TextFormatSerializer;
}
