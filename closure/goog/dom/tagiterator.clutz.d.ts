//!! generated by clutz.
// Generated from dom/tagiterator.js
declare namespace ಠ_ಠ.clutz.goog.dom {
  /**
   * A DOM tree traversal iterator.
   *
   * Starting with the given node, the iterator walks the DOM in order, reporting
   * events for the start and end of Elements, and the presence of text nodes. For
   * example:
   *
   * <pre>
   * &lt;div&gt;1&lt;span&gt;2&lt;/span&gt;3&lt;/div&gt;
   * </pre>
   *
   * Will return the following nodes:
   *
   * <code>[div, 1, span, 2, span, 3, div]</code>
   *
   * With the following states:
   *
   * <code>[START, OTHER, START, OTHER, END, OTHER, END]</code>
   *
   * And the following depths
   *
   * <code>[1, 1, 2, 2, 1, 1, 0]</code>
   *
   * Imagining <code>|</code> represents iterator position, the traversal stops at
   * each of the following locations:
   *
   * <pre>
   * &lt;div&gt;|1|&lt;span&gt;|2|&lt;/span&gt;|3|&lt;/div&gt;|
   * </pre>
   *
   * The iterator can also be used in reverse mode, which will return the nodes
   * and states in the opposite order.  The depths will be slightly different
   * since, like in normal mode, the depth is computed *after* the given node.
   *
   * Lastly, it is possible to create an iterator that is unconstrained, meaning
   * that it will continue iterating until the end of the document instead of
   * until exiting the start node.
   */
  class TagIterator extends ಠ_ಠ.clutz.goog.iter.Iterator < Node | null > {
    private noStructuralTyping_goog_dom_TagIterator : any;
    /**
     * A DOM tree traversal iterator.
     *
     * Starting with the given node, the iterator walks the DOM in order, reporting
     * events for the start and end of Elements, and the presence of text nodes. For
     * example:
     *
     * <pre>
     * &lt;div&gt;1&lt;span&gt;2&lt;/span&gt;3&lt;/div&gt;
     * </pre>
     *
     * Will return the following nodes:
     *
     * <code>[div, 1, span, 2, span, 3, div]</code>
     *
     * With the following states:
     *
     * <code>[START, OTHER, START, OTHER, END, OTHER, END]</code>
     *
     * And the following depths
     *
     * <code>[1, 1, 2, 2, 1, 1, 0]</code>
     *
     * Imagining <code>|</code> represents iterator position, the traversal stops at
     * each of the following locations:
     *
     * <pre>
     * &lt;div&gt;|1|&lt;span&gt;|2|&lt;/span&gt;|3|&lt;/div&gt;|
     * </pre>
     *
     * The iterator can also be used in reverse mode, which will return the nodes
     * and states in the opposite order.  The depths will be slightly different
     * since, like in normal mode, the depth is computed *after* the given node.
     *
     * Lastly, it is possible to create an iterator that is unconstrained, meaning
     * that it will continue iterating until the end of the document instead of
     * until exiting the start node.
     * @param opt_node The start node.  If unspecified or null, defaults to an empty iterator.
     * @param opt_reversed Whether to traverse the tree in reverse.
     * @param opt_unconstrained Whether the iterator is not constrained to the starting node and its children.
     * @param opt_tagType The type of the position. Defaults to the start of the given node for forward iterators, and the end of the node for reverse iterators.
     * @param opt_depth The starting tree depth.
     */
    constructor (opt_node ? : Node | null , opt_reversed ? : boolean , opt_unconstrained ? : boolean , opt_tagType ? : ಠ_ಠ.clutz.goog.dom.TagWalkType | null , opt_depth ? : number ) ;
    /**
     * Whether the iterator is constrained to the starting node and its children.
     */
    constrained : boolean ;
    /**
     * The tree depth of this position relative to where the iterator started.
     * The depth is considered to be the tree depth just past the current node,
     * so if an iterator is at position
     * <pre>
     * <div>|</div>
     * </pre>
     * (i.e. the node is the div and the type is START_TAG) its depth will be 1.
     */
    depth : number ;
    /**
     * The node this position is located on.
     */
    node : Node | null ;
    /**
     * Whether the node iterator is moving in reverse.
     */
    reversed : boolean ;
    /**
     * The type of this position.
     */
    tagType : ಠ_ಠ.clutz.goog.dom.TagWalkType ;
    clone ( ) : ಠ_ಠ.clutz.goog.dom.TagIterator ;
    /**
     * Replace this iterator's values with values from another. The two iterators
     * must be of the same type.
     * @param other The iterator to copy.
     */
    protected copyFrom (other : ಠ_ಠ.clutz.goog.dom.TagIterator | null ) : void ;
    /**
     * Test if two iterators are at the same position - i.e. if the node and tagType
     * is the same.  This will still return true if the two iterators are moving in
     * opposite directions or have different constraints.
     * @param other The iterator to compare to.
     */
    equals (other : ಠ_ಠ.clutz.goog.dom.TagIterator | null ) : boolean ;
    isEndTag ( ) : boolean ;
    isNonElement ( ) : boolean ;
    isStartTag ( ) : boolean ;
    protected isStarted ( ) : boolean ;
    /**
     * Move to the next position in the DOM tree.
     */
    next ( ) : IteratorResult < Node > ;
    restartTag ( ) : void ;
    /**
     * Set the position of the iterator.  Overwrite the tree node and the position
     * type which can be one of the {@link goog.dom.TagWalkType} token types.
     * Only overwrites the tree depth when the parameter is specified.
     * @param node The node to set the position to.
     * @param opt_tagType The type of the position Defaults to the start of the given node.
     * @param opt_depth The tree depth.
     */
    setPosition (node : Node | null , opt_tagType ? : ಠ_ಠ.clutz.goog.dom.TagWalkType | null , opt_depth ? : number ) : void ;
    skipTag ( ) : void ;
    /**
     * Replace the current node with the list of nodes. Reset the iterator so that
     * it visits the first of the nodes next.
     * @param var_args A list of nodes to replace the current node with. If the first argument is array-like, it will be used, otherwise all the arguments are assumed to be nodes.
     */
    splice ( ...var_args : ( GlobalObject | null ) [] ) : void ;
  }
}
declare module 'goog:goog.dom.TagIterator' {
  import TagIterator = ಠ_ಠ.clutz.goog.dom.TagIterator;
  export default TagIterator;
}
// Generated from dom/tagiterator.js
declare namespace ಠ_ಠ.clutz.goog.dom {
  /**
   * There are three types of token:
   * <ol>
   * <li>`START_TAG` - The beginning of a tag.
   * <li>`OTHER` - Any non-element node position.
   * <li>`END_TAG` - The end of a tag.
   * </ol>
   * Users of this enumeration can rely on {@code START_TAG + END_TAG = 0} and
   * that {@code OTHER = 0}.
   */
  /**
   * There are three types of token:
   * <ol>
   * <li>`START_TAG` - The beginning of a tag.
   * <li>`OTHER` - Any non-element node position.
   * <li>`END_TAG` - The end of a tag.
   * </ol>
   * Users of this enumeration can rely on {@code START_TAG + END_TAG = 0} and
   * that {@code OTHER = 0}.
   */
  enum TagWalkType {
    END_TAG = -1.0 ,
    OTHER = 0.0 ,
    START_TAG = 1.0 ,
  }
}
declare module 'goog:goog.dom.TagWalkType' {
  import TagWalkType = ಠ_ಠ.clutz.goog.dom.TagWalkType;
  export default TagWalkType;
}
