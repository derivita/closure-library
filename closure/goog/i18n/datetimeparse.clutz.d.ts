//!! generated by clutz.
// Generated from i18n/datetimeparse.js
declare namespace ಠ_ಠ.clutz.goog.i18n {
  /**
   * Construct a DateTimeParse based on current locale.
   */
  class DateTimeParse {
    private noStructuralTyping_goog_i18n_DateTimeParse : any;
    /**
     * Construct a DateTimeParse based on current locale.
     * @param pattern pattern specification or pattern type.
     * @param opt_dateTimeSymbols Optional symbols to use for this instance rather than the global symbols.
     */
    constructor (pattern : string | number , opt_dateTimeSymbols ? : GlobalObject ) ;
    /**
     * Parse the given string and fill parsed values into date object.
     *
     * The existing values of any temporal fields of `date` not parsed from `text`
     * are not directly changed, but may be affected by overflow. E.g. if a minutes
     * value of 70 is parsed, the implementation of `date` may increment the value
     * of its hours field by 1 while setting its minutes value to 10.
     * @param text The string being parsed.
     * @param date The Date object to hold the parsed date.
     * @param options The options object.
     */
    parse (text : string , date : ಠ_ಠ.clutz.goog.date.DateLike | null , options ? : ಠ_ಠ.clutz.goog.i18n.DateTimeParse.ParseOptions ) : number ;
    /**
     * Number of years prior to now that the century used to
     * disambiguate two digit years will begin
     */
    static ambiguousYearCenturyStart : number ;
  }
}
// Generated from i18n/datetimeparse.js
declare namespace ಠ_ಠ.clutz.goog.i18n.DateTimeParse {
  class MyDate_ {
    private noStructuralTyping_goog_i18n_DateTimeParse_MyDate_ : any;
    /**
     * Flag indicating if a provided two digit year needs to
     * be disambiguated
     */
    ambiguousYear : boolean ;
    /**
     * The date's before/afternoon denominator.
     */
    ampm : number | null ;
    /**
     * The date's day of month.
     */
    day : number | null ;
    /**
     * The date's day of week. Sunday is 0, Saturday is 6.
     */
    dayOfWeek : number | null ;
    /**
     * Index of the time's flexible day period in data object.
     */
    dayPeriodIndex : number ;
    /**
     * The name for flexible time of day.
     */
    dayPeriodName : string | null ;
    /**
     * The date's era.
     */
    era : number | null ;
    /**
     * The date's hour.
     */
    hours : number | null ;
    /**
     * The date's milliseconds.
     */
    milliseconds : number | null ;
    /**
     * The date's minutes.
     */
    minutes : number | null ;
    /**
     * The date's month.
     */
    month : number | null ;
    /**
     * The date's seconds.
     */
    seconds : number | null ;
    /**
     * The date's timezone offset.
     */
    tzOffset : number | null ;
    /**
     * The date's year.
     */
    year : number | null ;
  }
  interface ParseOptions {
    /**
     * Whether to use predictive parsing. Predictive parsing generates successful
     * parse results for non-empty partial inputs that have valid completions for
     * the parse pattern.
     *
     * If the end of the input is reached while parsing, numeric patterns parts
     * such as "HH" will infer values by padding with trailing 0s, and string
     * pattern parts such as "a" will attempt to prefix match valid values. E.g.
     * for the pattern "HH:mm" the input "12:3" will parse to a value equivalent
     * to "12:30" and for the pattern "h:mm a" the input "12:34 p" will parse to
     * a value equivalent to "12:30 PM".
     *
     * Predictive parsing currently only supports the pattern symbols "ahHkKm"
     * and is not compatible with abutting number patterns. Attempting to parse
     * using the predictive option with unsupported patterns will result in an
     * error being thrown.
     *
     * Defaults to false.
     */
    predictive ? : boolean ;
    /**
     * Whether the parsed date/time value should be validated.
     *
     * When true, parsing will fail if any of the parsed fields overflow, e.g.
     * minutes > 60.
     *
     * Note that setting `validate` to `false` does _not_ mean that parsing will
     * not fail: if the parser encounters an unknown month or day-of-week name
     * (for instance) then parsing will still fail. This only checks for overflow.
     *
     * Defaults to false.
     */
    validate ? : boolean ;
  }
}
declare module 'goog:goog.i18n.DateTimeParse' {
  import DateTimeParse = ಠ_ಠ.clutz.goog.i18n.DateTimeParse;
  export default DateTimeParse;
}
