//!! generated by clutz.
// Generated from module/modulemanager.js
declare namespace ಠ_ಠ.clutz.goog.module {
  /**
   * The ModuleManager keeps track of all modules in the environment.
   * Since modules may not have their code loaded, we must keep track of them.
   */
  class ModuleManager extends ಠ_ಠ.clutz.goog.loader.AbstractModuleManager implements ಠ_ಠ.clutz.goog.disposable.IDisposable {
    private noStructuralTyping_goog_module_ModuleManager : any;
    /**
     * The ModuleManager keeps track of all modules in the environment.
     * Since modules may not have their code loaded, we must keep track of them.
     */
    constructor ( ) ;
    /**
     * A mapping from module id to ModuleInfo object.
     */
    protected moduleInfoMap : { [ key: string ]: ಠ_ಠ.clutz.goog.module.ModuleInfo } ;
    addExtraEdge (fromModule ? : any , toModule ? : any ) : void ;
    beforeLoadModuleCode (id ? : any ) : void ;
    dispose ( ) : void ;
    execOnLoad (moduleId ? : any , fn ? : any , opt_handler ? : any , opt_noLoad ? : any , opt_userInitiated ? : any , opt_preferSynchronous ? : any ) : any ;
    getModuleInfo (id ? : any ) : any ;
    isActive ( ) : any ;
    isDisposed ( ) : any ;
    isModuleLoading (id ? : any ) : any ;
    isUserActive ( ) : any ;
    load (moduleId ? : any , opt_userInitiated ? : any ) : any ;
    loadMultiple (moduleIds ? : any , opt_userInitiated ? : any ) : any ;
    prefetchModule (id ? : any ) : void ;
    preloadModule (id ? : any , opt_timeout ? : any ) : any ;
    registerCallback (types ? : any , fn ? : any ) : void ;
    registerInitializationCallback (fn ? : any , opt_handler ? : any ) : void ;
    registerLateInitializationCallback (fn ? : any , opt_handler ? : any ) : void ;
    removeExtraEdge (fromModule ? : any , toModule ? : any ) : void ;
    setAllModuleInfo (infoMap ? : any ) : void ;
    setAllModuleInfoString (opt_info ? : any , opt_loadingModuleIds ? : any ) : void ;
    setBatchModeEnabled (enabled ? : any ) : void ;
    setConcurrentLoadingEnabled (enabled ? : any ) : void ;
    setLoaded ( ) : void ;
    setModuleConstructor (fn ? : any ) : void ;
    setModuleContext (context ? : any ) : void ;
    setModuleTrustedUris (moduleUriMap ? : any ) : void ;
    /**
     * A non-HTTP status code indicating a corruption in loaded module.
     * This should be used by a ModuleLoader as a replacement for the HTTP code
     * given to the error handler function to indicated that the module was
     * corrupted.
     * This will set the forceReload flag on the loadModules method when retrying
     * module loading.
     */
    static CORRUPT_RESPONSE_STATUS_CODE : number ;
    static SUBTRACTIVE_MODULE_LOADING : boolean ;
    static getInstance ( ) : ಠ_ಠ.clutz.goog.loader.AbstractModuleManager ;
  }
}
// Generated from module/modulemanager.js
declare namespace ಠ_ಠ.clutz.goog.module.ModuleManager {
  class ModuleFailureError extends ಠ_ಠ.clutz.goog.debug.Error {
    private noStructuralTyping_goog_module_ModuleManager_ModuleFailureError : any;
    /**
     * Error used to indicate a module has failed.
     * @param moduleID The id of the module that didn't load.
     */
    constructor (moduleID : string , failureType : ಠ_ಠ.clutz.goog.loader.AbstractModuleManager.FailureType | null ) ;
    failureType : ಠ_ಠ.clutz.goog.loader.AbstractModuleManager.FailureType | null ;
  }
}
declare module 'goog:goog.module.ModuleManager' {
  import ModuleManager = ಠ_ಠ.clutz.goog.module.ModuleManager;
  export default ModuleManager;
}
// Generated from module/modulemanager.js
declare namespace ಠ_ಠ.clutz.goog.module.ModuleManager {
  /**
   * The type of callbacks that can be registered with the module manager,.
   */
  //!! goog.module.ModuleManager.CallbackType aliases enum goog.loader.AbstractModuleManager.CallbackType
  export import CallbackType = goog.loader.AbstractModuleManager.CallbackType ;
}
declare module 'goog:goog.module.ModuleManager.CallbackType' {
  import CallbackType = ಠ_ಠ.clutz.goog.module.ModuleManager.CallbackType;
  export default CallbackType;
}
// Generated from module/modulemanager.js
declare namespace ಠ_ಠ.clutz.goog.module.ModuleManager {
  /**
   * The possible reasons for a module load failure callback being fired.
   */
  //!! goog.module.ModuleManager.FailureType aliases enum goog.module.ModuleLoadFailureType
  export import FailureType = goog.module.ModuleLoadFailureType ;
}
declare module 'goog:goog.module.ModuleManager.FailureType' {
  import FailureType = ಠ_ಠ.clutz.goog.module.ModuleManager.FailureType;
  export default FailureType;
}
