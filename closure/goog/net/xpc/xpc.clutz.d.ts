//!! generated by clutz.
// Generated from net/xpc/xpc.js
declare namespace ಠ_ಠ.clutz.goog.net.xpc {
  /**
   * Transport signaling message: setup.
   */
  let SETUP : string ;
  /**
   * Transport signaling message: setup acknowledgement.
   */
  let SETUP_ACK_NTPV2 : string ;
  /**
   * Transport signaling message: setup for native transport protocol v2.
   */
  let SETUP_NTPV2 : string ;
  /**
   * Returns a random string.
   * @param length How many characters the string shall contain.
   * @param opt_characters The characters used.
   */
  function getRandomString (length : number , opt_characters ? : string ) : string ;
  /**
   * The logger.
   */
  let logger : ಠ_ಠ.clutz.goog.log.Logger | null ;
}
declare module 'goog:goog.net.xpc' {
  import xpc = ಠ_ಠ.clutz.goog.net.xpc;
  export = xpc;
}
// Generated from net/xpc/xpc.js
declare namespace ಠ_ಠ.clutz.goog.net.xpc.CfgFields {
  /**
   * Authorization token. If set, NIX will use this authorization token
   * to validate the setup.
   */
  let AUTH_TOKEN : string ;
  /**
   * Channel name identifier.
   * Both peers have to be initialized with
   * the same channel name.  If not present, a channel name is
   * generated (which then has to transferred to the peer somehow).
   */
  let CHANNEL_NAME : string ;
  /**
   * Whether the direct transport runs in synchronous mode. The default is to
   * emulate the other transports and run asyncronously but there are some
   * circumstances where syncronous calls are required. If this property is
   * set to true, the transport will send the messages synchronously.
   */
  let DIRECT_TRANSPORT_SYNC_MODE : string ;
  /**
   * Ifame-ID identifier.
   * The id of the iframe element the peer-document lives in.
   */
  let IFRAME_ID : string ;
  /**
   * Local poll URI identifier (IframePollingTransport-specific).
   * The URI  (can't contain a fragment identifier)which is polled
   * to receive data from the peer.
   */
  let LOCAL_POLL_URI : string ;
  /**
   * Local relay URI identifier (IframeRelayTransport-specific).
   * The URI (can't contain a fragment identifier) used by the peer to
   * relay data through.
   */
  let LOCAL_RELAY_URI : string ;
  /**
   * Which version of the native transport startup protocol should be used, the
   * default being '2'.  Version 1 had various timing vulnerabilities, which
   * had to be compensated for by introducing delays, and is deprecated.  V1
   * and V2 are broadly compatible, although the more robust timing and lack
   * of delays is not gained unless both sides are using V2.  The only
   * unsupported case of cross-protocol interoperation is where a connection
   * starts out with V2 at both ends, and one of the ends reconnects as a V1.
   * All other initial startup and reconnection scenarios are supported.
   */
  let NATIVE_TRANSPORT_PROTOCOL_VERSION : string ;
  /**
   * Usually both frames using a connection initially send a SETUP message to
   * each other, and each responds with a SETUP_ACK.  A frame marks itself
   * connected when it receives that SETUP_ACK.  If this parameter is true
   * however, the channel it is passed to will not send a SETUP, but rather will
   * wait for one from its peer and mark itself connected when that arrives.
   * Peer iframes created using such a channel will send SETUP however, and will
   * wait for SETUP_ACK before marking themselves connected.  The goal is to
   * cope with a situation where the availability of the URL for the peer frame
   * cannot be relied on, eg when the application is offline.  Without this
   * setting, the primary frame will attempt to send its SETUP message every
   * 100ms, forever.  This floods the javascript console with uncatchable
   * security warnings, and fruitlessly burns CPU.  There is one scenario this
   * mode will not support, and that is reconnection by the outer frame, ie the
   * creation of a new channel object to connect to a peer iframe which was
   * already communicating with a previous channel object of the same name.  If
   * that behavior is needed, this mode should not be used.  Reconnection by
   * inner frames is supported in this mode however.
   */
  let ONE_SIDED_HANDSHAKE : string ;
  /**
   * The hostname of the peer window, including protocol, domain, and port
   * (if specified). Used for security sensitive applications that make
   * use of NativeMessagingTransport (i.e. most applications).
   */
  let PEER_HOSTNAME : string ;
  /**
   * Local poll URI identifier (IframePollingTransport-specific).
   * The URI (can't contain a fragment identifier) used to send data
   * to the peer.
   */
  let PEER_POLL_URI : string ;
  /**
   * Peer relay URI identifier (IframeRelayTransport-specific).
   * The URI (can't contain a fragment identifier) used to relay data
   * to the peer.
   */
  let PEER_RELAY_URI : string ;
  /**
   * The URI of the peer page.
   */
  let PEER_URI : string ;
  /**
   * Remote party's authorization token. If set, NIX will validate this
   * authorization token against that sent by the other party.
   */
  let REMOTE_AUTH_TOKEN : string ;
  /**
   * The frame role (inner or outer). Used to explicitly indicate the role for
   * each peer whenever the role cannot be reliably determined (e.g. the two
   * peer windows are not parent/child frames). If unspecified, the role will
   * be dynamically determined, assuming a parent/child frame setup.
   */
  let ROLE : string ;
  /**
   * Transport type identifier.
   * The transport type to use. Possible values are entries from
   * goog.net.xpc.TransportTypes or a Transport constructor fuction. If not
   * present, the transport is determined automatically based on the useragent's
   * capabilities.
   */
  let TRANSPORT : string ;
}
declare module 'goog:goog.net.xpc.CfgFields' {
  import CfgFields = ಠ_ಠ.clutz.goog.net.xpc.CfgFields;
  export = CfgFields;
}
// Generated from net/xpc/xpc.js
declare namespace ಠ_ಠ.clutz.goog.net.xpc {
  enum ChannelStates {
    CLOSED = 3.0 ,
    CONNECTED = 2.0 ,
    NOT_CONNECTED = 1.0 ,
  }
}
declare module 'goog:goog.net.xpc.ChannelStates' {
  import ChannelStates = ಠ_ಠ.clutz.goog.net.xpc.ChannelStates;
  export default ChannelStates;
}
// Generated from net/xpc/xpc.js
declare namespace ಠ_ಠ.clutz.goog.net.xpc {
  /**
   * Enum containing transport names. These need to correspond to the
   * transport class names for createTransport_() to work.
   */
  let TransportNames : { [ key: string ]: string } ;
}
declare module 'goog:goog.net.xpc.TransportNames' {
  import TransportNames = ಠ_ಠ.clutz.goog.net.xpc.TransportNames;
  export default TransportNames;
}
// Generated from net/xpc/xpc.js
declare namespace ಠ_ಠ.clutz.goog.net.xpc {
  /**
   * Enum used to identify transport types.
   */
  /**
   * Enum used to identify transport types.
   */
  enum TransportTypes {
    DIRECT = 2.0 ,
    NATIVE_MESSAGING = 1.0 ,
    UNDEFINED = 0.0 ,
  }
}
declare module 'goog:goog.net.xpc.TransportTypes' {
  import TransportTypes = ಠ_ಠ.clutz.goog.net.xpc.TransportTypes;
  export default TransportTypes;
}
// Generated from net/xpc/xpc.js
declare namespace ಠ_ಠ.clutz.goog.net.xpc {
  /**
   * Config properties that need to be URL sanitized.
   */
  let UriCfgFields : string [] | null ;
}
declare module 'goog:goog.net.xpc.UriCfgFields' {
  import UriCfgFields = ಠ_ಠ.clutz.goog.net.xpc.UriCfgFields;
  export default UriCfgFields;
}
