//!! generated by clutz.
// Generated from promise/promise.js
declare namespace ಠ_ಠ.clutz.goog {
  /**
   * NOTE: This class was created in anticipation of the built-in Promise type
   * being standardized and implemented across browsers. Now that Promise is
   * available in modern browsers, and is automatically polyfilled by the Closure
   * Compiler, by default, most new code should use native `Promise`
   * instead of `goog.Promise`. However, `goog.Promise` has the
   * concept of cancellation which native Promises do not yet have. So code
   * needing cancellation may still want to use `goog.Promise`.
   *
   * Promises provide a result that may be resolved asynchronously. A Promise may
   * be resolved by being fulfilled with a fulfillment value, rejected with a
   * rejection reason, or blocked by another Promise. A Promise is said to be
   * settled if it is either fulfilled or rejected. Once settled, the Promise
   * result is immutable.
   *
   * Promises may represent results of any type, including undefined. Rejection
   * reasons are typically Errors, but may also be of any type. Closure Promises
   * allow for optional type annotations that enforce that fulfillment values are
   * of the appropriate types at compile time.
   *
   * The result of a Promise is accessible by calling `then` and registering
   * `onFulfilled` and `onRejected` callbacks. Once the Promise
   * is settled, the relevant callbacks are invoked with the fulfillment value or
   * rejection reason as argument. Callbacks are always invoked in the order they
   * were registered, even when additional `then` calls are made from inside
   * another callback. A callback is always run asynchronously sometime after the
   * scope containing the registering `then` invocation has returned.
   *
   * If a Promise is resolved with another Promise, the first Promise will block
   * until the second is settled, and then assumes the same result as the second
   * Promise. This allows Promises to depend on the results of other Promises,
   * linking together multiple asynchronous operations.
   *
   * This implementation is compatible with the Promises/A+ specification and
   * passes that specification's conformance test suite. A Closure Promise may be
   * resolved with a Promise instance (or sufficiently compatible Promise-like
   * object) created by other Promise implementations. From the specification,
   * Promise-like objects are known as "Thenables".
   */
  class Promise < TYPE = any , RESOLVER_CONTEXT = any > implements ಠ_ಠ.clutz.goog.Thenable < TYPE > {
    private noStructuralTyping_goog_Promise : any;
    /**
     * NOTE: This class was created in anticipation of the built-in Promise type
     * being standardized and implemented across browsers. Now that Promise is
     * available in modern browsers, and is automatically polyfilled by the Closure
     * Compiler, by default, most new code should use native `Promise`
     * instead of `goog.Promise`. However, `goog.Promise` has the
     * concept of cancellation which native Promises do not yet have. So code
     * needing cancellation may still want to use `goog.Promise`.
     *
     * Promises provide a result that may be resolved asynchronously. A Promise may
     * be resolved by being fulfilled with a fulfillment value, rejected with a
     * rejection reason, or blocked by another Promise. A Promise is said to be
     * settled if it is either fulfilled or rejected. Once settled, the Promise
     * result is immutable.
     *
     * Promises may represent results of any type, including undefined. Rejection
     * reasons are typically Errors, but may also be of any type. Closure Promises
     * allow for optional type annotations that enforce that fulfillment values are
     * of the appropriate types at compile time.
     *
     * The result of a Promise is accessible by calling `then` and registering
     * `onFulfilled` and `onRejected` callbacks. Once the Promise
     * is settled, the relevant callbacks are invoked with the fulfillment value or
     * rejection reason as argument. Callbacks are always invoked in the order they
     * were registered, even when additional `then` calls are made from inside
     * another callback. A callback is always run asynchronously sometime after the
     * scope containing the registering `then` invocation has returned.
     *
     * If a Promise is resolved with another Promise, the first Promise will block
     * until the second is settled, and then assumes the same result as the second
     * Promise. This allows Promises to depend on the results of other Promises,
     * linking together multiple asynchronous operations.
     *
     * This implementation is compatible with the Promises/A+ specification and
     * passes that specification's conformance test suite. A Closure Promise may be
     * resolved with a Promise instance (or sufficiently compatible Promise-like
     * object) created by other Promise implementations. From the specification,
     * Promise-like objects are known as "Thenables".
     * @param resolver Initialization function that is invoked immediately with `resolve` and `reject` functions as arguments. The Promise is resolved or rejected with the first argument passed to either function.
     * @param opt_context An optional context for executing the resolver function. If unspecified, the resolver function will be executed in the default scope.
     */
    constructor (resolver : (this : RESOLVER_CONTEXT , a : (a ? : TYPE | PromiseLike < TYPE > | null | { then : any } ) => any , b : (a ? : any ) => any ) => void , opt_context ? : RESOLVER_CONTEXT ) ;
    /**
     * Cancels the Promise if it is still pending by rejecting it with a cancel
     * Error. No action is performed if the Promise is already resolved.
     *
     * All child Promises of the canceled Promise will be rejected with the same
     * cancel error, as with normal Promise rejection. If the Promise to be canceled
     * is the only child of a pending Promise, the parent Promise will also be
     * canceled. Cancellation may propagate upward through multiple generations.
     * @param opt_message An optional debugging message for describing the cancellation reason.
     */
    cancel (opt_message ? : string ) : void ;
    /**
     * Adds a callback that will be invoked only if the Promise is rejected. This
     * is equivalent to `then(null, onRejected)`.
     * @param onRejected A function that will be invoked with the rejection reason if this Promise is rejected.
     * @param opt_context An optional context object that will be the execution context for the callbacks. By default, functions are executed in the global scope.
     */
    catch < THIS = any > (a : (this : THIS , a : any ) => any , b ? : THIS ) : ಠ_ಠ.clutz.goog.Promise < any , any > ;
    /**
     * Adds callbacks that will operate on the result of the Promise, returning a
     * new child Promise.
     *
     * If the Promise is fulfilled, the `onFulfilled` callback will be invoked
     * with the fulfillment value as argument, and the child Promise will be
     * fulfilled with the return value of the callback. If the callback throws an
     * exception, the child Promise will be rejected with the thrown value instead.
     *
     * If the Promise is rejected, the `onRejected` callback will be invoked
     * with the rejection reason as argument, and the child Promise will be resolved
     * with the return value or rejected with the thrown value of the callback.
     * @param opt_onFulfilled A function that will be invoked with the fulfillment value if the Promise is fulfilled.
     * @param opt_onRejected A function that will be invoked with the rejection reason if the Promise is rejected.
     * @param opt_context An optional context object that will be the execution context for the callbacks. By default, functions are executed with the default this.
     */
    then < RESULT > (opt_onFulfilled ? : ( (a : TYPE ) => PromiseLike < RESULT > | RESULT ) | null , opt_onRejected ? : ( (a : any ) => any ) | null) :  any ;
    /**
     * Adds a callback that will be invoked when the Promise is settled (fulfilled
     * or rejected). The callback receives no argument, and no new child Promise is
     * created. This is useful for ensuring that cleanup takes place after certain
     * asynchronous operations. Callbacks added with `thenAlways` will be
     * executed in the same order with other calls to `then`,
     * `thenAlways`, or `thenCatch`.
     *
     * Since it does not produce a new child Promise, cancellation propagation is
     * not prevented by adding callbacks with `thenAlways`. A Promise that has
     * a cleanup handler added with `thenAlways` will be canceled if all of
     * its children created by `then` (or `thenCatch`) are canceled.
     * Additionally, since any rejections are not passed to the callback, it does
     * not stop the unhandled rejection handler from running.
     * @param onSettled A function that will be invoked when the Promise is settled (fulfilled or rejected).
     * @param opt_context An optional context object that will be the execution context for the callbacks. By default, functions are executed in the global scope.
     */
    thenAlways < THIS = any > (onSettled : (this : THIS ) => void , opt_context ? : THIS ) : ಠ_ಠ.clutz.goog.Promise < TYPE , any > ;
    /**
     * Adds a callback that will be invoked only if the Promise is rejected. This
     * is equivalent to `then(null, onRejected)`.
     *
     * Note: Prefer using `catch` which is interoperable with native browser
     * Promises.
     * @param onRejected A function that will be invoked with the rejection reason if this Promise is rejected.
     * @param opt_context An optional context object that will be the execution context for the callbacks. By default, functions are executed in the global scope.
     */
    thenCatch < THIS = any > (onRejected : (this : THIS , a : any ) => any , opt_context ? : THIS ) : ಠ_ಠ.clutz.goog.Promise < any , any > ;
    static DEFAULT_MAX_UNUSED : number ;
    static LONG_STACK_TRACES : boolean ;
    static UNHANDLED_REJECTION_DELAY : number ;
    static all < TYPE = any > (promises : any [] ) : ಠ_ಠ.clutz.goog.Promise < TYPE [] , any > ;
    static allSettled < TYPE = any > (promises : any [] ) : ಠ_ಠ.clutz.goog.Promise < { fulfilled : boolean , reason ? : any , value ? : TYPE } [] , any > ;
    static firstFulfilled < TYPE = any > (promises : any [] ) : ಠ_ಠ.clutz.goog.Promise < TYPE , any > ;
    static race < TYPE = any > (promises : any [] ) : ಠ_ಠ.clutz.goog.Promise < TYPE , any > ;
    static reject (opt_reason ? : any ) : ಠ_ಠ.clutz.goog.Promise < any , any > ;
    static resolve < T >(value: PromiseLike < T > | T): any;
    /**
     * Sets a handler that will be called with reasons from unhandled rejected
     * Promises. If the rejected Promise (or one of its descendants) has an
     * `onRejected` callback registered, the rejection will be considered
     * handled, and the rejection handler will not be called.
     *
     * By default, unhandled rejections are rethrown so that the error may be
     * captured by the developer console or a `window.onerror` handler.
     * @param handler A function that will be called with reasons from rejected Promises. Defaults to `goog.async.throwException`.
     */
    static setUnhandledRejectionHandler (handler : (a : any ) => any ) : void ;
    static withResolver < TYPE = any > ( ) : ಠ_ಠ.clutz.goog.promise.Resolver < TYPE > ;
  }
}
// Generated from promise/promise.js
declare namespace ಠ_ಠ.clutz.goog.Promise {
  class CallbackEntry_ {
    private noStructuralTyping_goog_Promise_CallbackEntry_ : any;
    /**
     * A boolean value to indicate this is a "thenAlways" callback entry.
     * Unlike a normal "then/thenVoid" a "thenAlways doesn't participate
     * in "cancel" considerations but is simply an observer and requires
     * special handling.
     */
    always : boolean ;
    child : ಠ_ಠ.clutz.goog.Promise < any , any > | null ;
    context : any ;
    next : ಠ_ಠ.clutz.goog.Promise.CallbackEntry_ | null ;
    onFulfilled : Function | null ;
    onRejected : Function | null ;
    reset ( ) : void ;
  }
  class CancellationError extends ಠ_ಠ.clutz.goog.debug.Error {
    private noStructuralTyping_goog_Promise_CancellationError : any;
    /**
     * Error used as a rejection reason for canceled Promises.  This will still be
     * a rejection, but should generally be ignored by other error handlers (because
     * cancellation should not be a reportable error).
     */
    constructor (opt_message ? : string ) ;
    reportErrorToServer : boolean ;
    name : string ;
  }
  class Resolver_ < TYPE = any > implements ಠ_ಠ.clutz.goog.promise.Resolver < TYPE > {
    private noStructuralTyping_goog_Promise_Resolver_ : any;
    promise : ಠ_ಠ.clutz.goog.Promise < TYPE , any > ;
    reject (a ? : any ) : void ;
    resolve (a ? : TYPE | ಠ_ಠ.clutz.goog.Promise < TYPE , any > | null | { then : any } ) : any ;
  }
}
declare module 'goog:goog.Promise' {
  import Promise = ಠ_ಠ.clutz.goog.Promise;
  export default Promise;
}
