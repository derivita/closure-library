//!! generated by clutz.
// Generated from messaging/multichannel.js
declare namespace ಠ_ಠ.clutz.goog.messaging {
  /**
   * Creates a new MultiChannel wrapping a single MessageChannel. The
   * underlying channel shouldn't have any other listeners registered, but it
   * should be connected.
   *
   * Note that the other side of the channel should also be connected to a
   * MultiChannel with the same number of virtual channels.
   */
  class MultiChannel extends ಠ_ಠ.clutz.goog.Disposable {
    private noStructuralTyping_goog_messaging_MultiChannel : any;
    /**
     * Creates a new MultiChannel wrapping a single MessageChannel. The
     * underlying channel shouldn't have any other listeners registered, but it
     * should be connected.
     *
     * Note that the other side of the channel should also be connected to a
     * MultiChannel with the same number of virtual channels.
     * @param underlyingChannel The underlying channel to use as transport for the virtual channels.
     */
    constructor (underlyingChannel : ಠ_ಠ.clutz.goog.messaging.MessageChannel | null ) ;
    /**
     * Creates a new virtual channel that will communicate across the underlying
     * channel.
     * @param name The name of the virtual channel. Must be unique for this MultiChannel. Cannot contain colons.
     */
    createVirtualChannel (name : string ) : ಠ_ಠ.clutz.goog.messaging.MultiChannel.VirtualChannel ;
    disposeInternal ( ) : void ;
  }
}
declare module 'goog:goog.messaging.MultiChannel' {
  import MultiChannel = ಠ_ಠ.clutz.goog.messaging.MultiChannel;
  export default MultiChannel;
}
// Generated from messaging/multichannel.js
declare namespace ಠ_ಠ.clutz.goog.messaging.MultiChannel {
  /**
   * A message channel that proxies its messages over another underlying channel.
   */
  class VirtualChannel extends ಠ_ಠ.clutz.goog.Disposable implements ಠ_ಠ.clutz.goog.messaging.MessageChannel {
    private noStructuralTyping_goog_messaging_MultiChannel_VirtualChannel : any;
    /**
     * A message channel that proxies its messages over another underlying channel.
     * @param parent The MultiChannel which created this channel, and which contains the underlying MessageChannel that's used as the transport.
     * @param name The name of this virtual channel. Unique among the virtual channels in parent.
     */
    constructor (parent : ಠ_ಠ.clutz.goog.messaging.MultiChannel | null , name : string ) ;
    /**
     * This is a no-op, since the underlying channel is expected to already be
     * initialized when it's passed in.
     */
    connect (opt_connectCb ? : any ) : void ;
    disposeInternal ( ) : void ;
    /**
     * This always returns true, since the underlying channel is expected to already
     * be initialized when it's passed in.
     */
    isConnected ( ) : any ;
    registerDefaultService (callback ? : any ) : void ;
    registerService (serviceName ? : any , callback ? : any , opt_objectPayload ? : any ) : void ;
    send (serviceName ? : any , payload ? : any ) : void ;
  }
}
declare module 'goog:goog.messaging.MultiChannel.VirtualChannel' {
  import VirtualChannel = ಠ_ಠ.clutz.goog.messaging.MultiChannel.VirtualChannel;
  export default VirtualChannel;
}
