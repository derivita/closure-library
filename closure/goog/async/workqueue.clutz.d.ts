//!! generated by clutz.
// Generated from async/workqueue.js
declare namespace ಠ_ಠ.clutz.goog.async {
  export import WorkQueue = ಠ_ಠ.clutz.module$contents$goog$async$WorkQueue_WorkQueue ;
}
declare module 'goog:goog.async.WorkQueue' {
  import WorkQueue = ಠ_ಠ.clutz.goog.async.WorkQueue;
  export default WorkQueue;
}
// Generated from async/workqueue.js
declare namespace ಠ_ಠ.clutz {
  /**
   * A low GC workqueue. The key elements of this design:
   * - avoids the need for goog.bind or equivalent by carrying scope
   * - avoids the need for array reallocation by using a linked list
   * - minimizes work entry objects allocation by recycling objects
   */
  class module$contents$goog$async$WorkQueue_WorkQueue {
    private noStructuralTyping_module$contents$goog$async$WorkQueue_WorkQueue : any;
    workHead_ : null | module$contents$goog$async$WorkQueue_WorkItem ;
    workTail_ : null | module$contents$goog$async$WorkQueue_WorkItem ;
    add (fn : ( ) => any , scope : GlobalObject | null | undefined ) : void ;
    remove ( ) : module$contents$goog$async$WorkQueue_WorkItem | null ;
    returnUnused (item : module$contents$goog$async$WorkQueue_WorkItem ) : void ;
    static DEFAULT_MAX_UNUSED : number ;
  }
}
// Generated from async/workqueue.js
declare namespace ಠ_ಠ.clutz {
  class module$contents$goog$async$WorkQueue_WorkItem {
    private noStructuralTyping_module$contents$goog$async$WorkQueue_WorkItem : any;
    fn : ( ( ) => any ) | null ;
    next : module$contents$goog$async$WorkQueue_WorkItem | null ;
    scope ? : GlobalObject | null ;
    /**
     * Reset the work item so they don't prevent GC before reuse
     */
    reset ( ) : void ;
    set (fn : ( ) => any , scope : GlobalObject | null | undefined ) : void ;
  }
}
declare namespace ಠ_ಠ.clutz {
  export import module$exports$goog$async$WorkQueue = ಠ_ಠ.clutz.module$contents$goog$async$WorkQueue_WorkQueue ;
}
