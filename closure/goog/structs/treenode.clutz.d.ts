//!! generated by clutz.
// Generated from structs/treenode.js
declare namespace ಠ_ಠ.clutz.goog.structs {
  /**
   * Generic tree node data structure with arbitrary number of child nodes.
   * It is possible to create a dynamic tree structure by overriding
   * {@link #getParent} and {@link #getChildren} in a subclass. All other getters
   * will automatically work.
   */
  class TreeNode < KEY = any , VALUE = any > extends ಠ_ಠ.clutz.goog.structs.Node < KEY , VALUE > {
    private noStructuralTyping_goog_structs_TreeNode : any;
    /**
     * Generic tree node data structure with arbitrary number of child nodes.
     * It is possible to create a dynamic tree structure by overriding
     * {@link #getParent} and {@link #getChildren} in a subclass. All other getters
     * will automatically work.
     * @param key Key.
     * @param value Value.
     */
    constructor (key : KEY , value : VALUE ) ;
    /**
     * Appends a child node to this node.
     * @param child Orphan child node.
     */
    addChild (child : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ) : void ;
    /**
     * Inserts a child node at the given index.
     * @param child Orphan child node.
     * @param index The position to insert at.
     */
    addChildAt (child : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > , index : number ) : void ;
    clone ( ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ;
    /**
     * Tells whether this node is the ancestor of the given node.
     * @param node A node.
     */
    contains (node : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ) : boolean ;
    deepClone ( ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ;
    /**
     * Traverses all child nodes.
     * @param f Callback function. It takes the node, its index and the array of all child nodes as arguments.
     * @param opt_this The object to be used as the value of `this` within `f`.
     */
    forEachChild < THIS = any > (f : (this : THIS , a : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > , b : number , c : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > [] ) => any , opt_this ? : THIS ) : void ;
    /**
     * Traverses all child nodes recursively in preorder.
     * @param f Callback function.  It takes the node as argument.
     * @param opt_this The object to be used as the value of `this` within `f`.
     */
    forEachDescendant < THIS = any > (f : (this : THIS , a : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ) => any , opt_this ? : THIS ) : void ;
    getAncestors ( ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > [] ;
    /**
     * Gets the child node of this node at the given index.
     * @param index Child index.
     */
    getChildAt (index : number ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ;
    getChildCount ( ) : number ;
    getChildren ( ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > [] ;
    getDepth ( ) : number ;
    /**
     * Returns a node whose key matches the given one in the hierarchy rooted at
     * this node. The hierarchy is searched using an in-order traversal.
     * @param key The key to search for.
     */
    getNodeByKey (key : KEY ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ;
    getParent ( ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ;
    getRoot ( ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ;
    /**
     * Builds a nested array structure from the node keys in this node's subtree to
     * facilitate testing tree operations that change the hierarchy.
     */
    getSubtreeKeys ( ) : KEY [] ;
    /**
     * Tells if the node is the last child of its parent. This method helps how to
     * connect the tree nodes with lines: L shapes should be used before the last
     * children and |- shapes before the rest. Schematic tree visualization:
     *
     * <pre>
     * Node1
     * |-Node2
     * | L-Node3
     * |   |-Node4
     * |   L-Node5
     * L-Node6
     * </pre>
     */
    isLastChild ( ) : boolean ;
    isLeaf ( ) : boolean ;
    /**
     * Removes the given child node of this node.
     * @param child The node to remove.
     */
    removeChild (child : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ;
    /**
     * Removes the child node at the given index.
     * @param index The position to remove from.
     */
    removeChildAt (index : number ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ;
    removeChildren ( ) : void ;
    /**
     * Replaces the given child node.
     * @param newChild New node to replace `oldChild`. It must not have parent node.
     * @param oldChild Existing child node to be replaced.
     */
    replaceChild (newChild : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > , oldChild : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ;
    /**
     * Replaces a child node at the given index.
     * @param newChild Child node to set. It must not have parent node.
     * @param index Valid index of the old child to replace.
     */
    replaceChildAt (newChild : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > , index : number ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ;
    /**
     * Sets the parent node of this node. The callers must ensure that the parent
     * node and only that has this node among its children.
     * @param parent The parent to set. If null, the node will be detached from the tree.
     */
    protected setParent (parent : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ) : void ;
    /**
     * Traverses the subtree with the possibility to skip branches. Starts with
     * this node, and visits the descendant nodes depth-first, in preorder.
     * @param f Callback function. It takes the node as argument. The children of this node will be visited if the callback returns true or undefined, and will be skipped if the callback returns false.
     * @param opt_this The object to be used as the value of `this` within `f`.
     */
    traverse < THIS = any > (f : (this : THIS , a : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > ) => boolean | undefined , opt_this ? : THIS ) : void ;
    /**
     * Finds the deepest common ancestor of the given nodes. The concept of
     * ancestor is not strict in this case, it includes the node itself.
     * @param var_args The nodes.
     */
    static findCommonAncestor < KEY = any , VALUE = any > ( ...var_args : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > [] ) : ಠ_ಠ.clutz.goog.structs.TreeNode < any , any > | null ;
  }
}
declare module 'goog:goog.structs.TreeNode' {
  import TreeNode = ಠ_ಠ.clutz.goog.structs.TreeNode;
  export default TreeNode;
}
