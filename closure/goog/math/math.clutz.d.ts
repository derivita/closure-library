//!! generated by clutz.
// Generated from math/math.js
declare namespace ಠ_ಠ.clutz.goog.math {
  /**
   * Computes the angle between two points (x1,y1) and (x2,y2).
   * Angle zero points in the +X direction, 90 degrees points in the +Y
   * direction (down) and from there we grow clockwise towards 360 degrees.
   * @param x1 x of first point.
   * @param y1 y of first point.
   * @param x2 x of second point.
   * @param y2 y of second point.
   */
  function angle (x1 : number , y1 : number , x2 : number , y2 : number ) : number ;
  /**
   * Computes the difference between startAngle and endAngle (angles in degrees).
   * @param startAngle Start angle in degrees.
   * @param endAngle End angle in degrees.
   */
  function angleDifference (startAngle : number , endAngle : number ) : number ;
  /**
   * For a given angle and radius, finds the X portion of the offset.
   * @param degrees Angle in degrees (zero points in +X direction).
   * @param radius Radius.
   */
  function angleDx (degrees : number , radius : number ) : number ;
  /**
   * For a given angle and radius, finds the Y portion of the offset.
   * @param degrees Angle in degrees (zero points in +X direction).
   * @param radius Radius.
   */
  function angleDy (degrees : number , radius : number ) : number ;
  /**
   * Returns the arithmetic mean of the arguments.
   * @param var_args Numbers to average.
   */
  function average ( ...var_args : number [] ) : number ;
  /**
   * Takes a number and clamps it to within the provided bounds.
   * @param value The input number.
   * @param min The minimum value to return.
   * @param max The maximum value to return.
   */
  function clamp (value : number , min : number , max : number ) : number ;
  /**
   * Returns whether the supplied number is finite and not NaN.
   * @param num The number to test.
   */
  function isFiniteNumber (num : number ) : boolean ;
  /**
   * Returns whether the supplied number represents an integer, i.e. that is has
   * no fractional component.  No range-checking is performed on the number.
   * @param num The number to test.
   */
  function isInt (num : number ) : boolean ;
  function isNegativeZero (num : number ) : boolean ;
  /**
   * Performs linear interpolation between values a and b. Returns the value
   * between a and b proportional to x (when x is between 0 and 1. When x is
   * outside this range, the return value is a linear extrapolation).
   * @param a A number.
   * @param b A number.
   * @param x The proportion between a and b.
   */
  function lerp (a : number , b : number , x : number ) : number ;
  /**
   * Returns the precise value of floor(log10(num)).
   * Simpler implementations didn't work because of floating point rounding
   * errors. For example
   * <ul>
   * <li>Math.floor(Math.log(num) / Math.LN10) is off by one for num == 1e+3.
   * <li>Math.floor(Math.log(num) * Math.LOG10E) is off by one for num == 1e+15.
   * <li>Math.floor(Math.log10(num)) is off by one for num == 1e+15 - 1.
   * </ul>
   * @param num A floating point number.
   */
  function log10Floor (num : number ) : number ;
  /**
   * JavaScript implementation of Longest Common Subsequence problem.
   * http://en.wikipedia.org/wiki/Longest_common_subsequence
   *
   * Returns the longest possible array that is subarray of both of given arrays.
   * @param array1 First array of objects.
   * @param array2 Second array of objects.
   * @param opt_compareFn Function that acts as a custom comparator for the array ojects. Function should return true if objects are equal, otherwise false.
   * @param opt_collectorFn Function used to decide what to return as a result subsequence. It accepts 2 arguments: index of common element in the first array and index in the second. The default function returns element from the first array.
   */
  function longestCommonSubsequence < S = any , T = any > (array1 : ArrayLike < S > | null , array2 : ArrayLike < T > | null , opt_compareFn ? : Function | null , opt_collectorFn ? : Function | null ) : ( S | T ) [] ;
  /**
   * The % operator in JavaScript returns the remainder of a / b, but differs from
   * some other languages in that the result will have the same sign as the
   * dividend. For example, -1 % 8 == -1, whereas in some other languages
   * (such as Python) the result would be 7. This function emulates the more
   * correct modulo behavior, which is useful for certain applications such as
   * calculating an offset index in a circular list.
   * @param a The dividend.
   * @param b The divisor.
   */
  function modulo (a : number , b : number ) : number ;
  /**
   * Tests whether the two values are equal to each other, within a certain
   * tolerance to adjust for floating point errors.
   * @param a A number.
   * @param b A number.
   * @param opt_tolerance Optional tolerance range. Defaults to 0.000001. If specified, should be greater than 0.
   */
  function nearlyEquals (a : number , b : number , opt_tolerance ? : number ) : boolean ;
  /**
   * Returns a random integer greater than or equal to 0 and less than `a`.
   * @param a The upper bound for the random integer (exclusive).
   */
  function randomInt (a : number ) : number ;
  /**
   * A tweaked variant of `Math.ceil`. See `goog.math.safeFloor` for
   * details.
   * @param num A number.
   * @param opt_epsilon An infinitesimally small positive number, the rounding error to tolerate.
   */
  function safeCeil (num : number , opt_epsilon ? : number ) : number ;
  /**
   * A tweaked variant of `Math.floor` which tolerates if the passed number
   * is infinitesimally smaller than the closest integer. It often happens with
   * the results of floating point calculations because of the finite precision
   * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
   * Math.LN10) == 2}, not 3 as one would expect.
   * @param num A number.
   * @param opt_epsilon An infinitesimally small positive number, the rounding error to tolerate.
   */
  function safeFloor (num : number , opt_epsilon ? : number ) : number ;
  /**
   * Returns the unbiased sample variance of the arguments. For a definition,
   * see e.g. http://en.wikipedia.org/wiki/Variance
   * @param var_args Number samples to analyze.
   */
  function sampleVariance ( ...var_args : number [] ) : number ;
  /**
   * Returns the sign of a number as per the "sign" or "signum" function.
   * @param x The number to take the sign of.
   */
  function sign (x : number ) : number ;
  /**
   * Normalizes an angle to be in range [0-360). Angles outside this range will
   * be normalized to be the equivalent angle with that range.
   * @param angle Angle in degrees.
   */
  function standardAngle (angle : number ) : number ;
  /**
   * Normalizes an angle to be in range [0-2*PI). Angles outside this range will
   * be normalized to be the equivalent angle with that range.
   * @param angle Angle in radians.
   */
  function standardAngleInRadians (angle : number ) : number ;
  /**
   * Returns the sample standard deviation of the arguments.  For a definition of
   * sample standard deviation, see e.g.
   * http://en.wikipedia.org/wiki/Standard_deviation
   * @param var_args Number samples to analyze.
   */
  function standardDeviation ( ...var_args : number [] ) : number ;
  /**
   * Returns the sum of the arguments.
   * @param var_args Numbers to add.
   */
  function sum ( ...var_args : number [] ) : number ;
  /**
   * Converts radians to degrees.
   * @param angleRadians Angle in radians.
   */
  function toDegrees (angleRadians : number ) : number ;
  /**
   * Converts degrees to radians.
   * @param angleDegrees Angle in degrees.
   */
  function toRadians (angleDegrees : number ) : number ;
  /**
   * Returns a random number greater than or equal to `a` and less than
   * `b`.
   * @param a The lower bound for the random number (inclusive).
   * @param b The upper bound for the random number (exclusive).
   */
  function uniformRandom (a : number , b : number ) : number ;
}
declare module 'goog:goog.math' {
  import math = ಠ_ಠ.clutz.goog.math;
  export = math;
}
