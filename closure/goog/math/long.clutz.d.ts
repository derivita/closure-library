//!! generated by clutz.
// Generated from math/long.js
declare namespace ಠ_ಠ.clutz.goog.math {
  export import Long = ಠ_ಠ.clutz.module$contents$goog$math$Long_Long ;
}
declare module 'goog:goog.math.Long' {
  import Long = ಠ_ಠ.clutz.goog.math.Long;
  export default Long;
}
// Generated from math/long.js
declare namespace ಠ_ಠ.clutz {
  /**
   * Represents a 64-bit two's-complement integer, given its low and high 32-bit
   * values as *signed* integers.  See the from* functions below for more
   * convenient ways of constructing Longs.
   *
   * The internal representation of a long is the two given signed, 32-bit values.
   * We use 32-bit pieces because these are the size of integers on which
   * JavaScript performs bit-operations.  For operations like addition and
   * multiplication, we split each number into 16-bit pieces, which can easily be
   * multiplied within JavaScript's floating-point representation without overflow
   * or change in sign.
   *
   * In the algorithms below, we frequently reduce the negative case to the
   * positive case by negating the input(s) and then post-processing the result.
   * Note that we must ALWAYS check specially whether those values are MIN_VALUE
   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   * a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   */
  class module$contents$goog$math$Long_Long {
    private noStructuralTyping_module$contents$goog$math$Long_Long : any;
    /**
     * Represents a 64-bit two's-complement integer, given its low and high 32-bit
     * values as *signed* integers.  See the from* functions below for more
     * convenient ways of constructing Longs.
     *
     * The internal representation of a long is the two given signed, 32-bit values.
     * We use 32-bit pieces because these are the size of integers on which
     * JavaScript performs bit-operations.  For operations like addition and
     * multiplication, we split each number into 16-bit pieces, which can easily be
     * multiplied within JavaScript's floating-point representation without overflow
     * or change in sign.
     *
     * In the algorithms below, we frequently reduce the negative case to the
     * positive case by negating the input(s) and then post-processing the result.
     * Note that we must ALWAYS check specially whether those values are MIN_VALUE
     * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     * a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     */
    constructor (low : number , high : number ) ;
    /**
     * Returns the sum of this and the given Long.
     * @param other Long to add to this one.
     */
    add (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @param other The Long with which to AND.
     */
    and (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    /**
     * Compares this Long with the given one.
     * @param other Long to compare against.
     */
    compare (other : module$contents$goog$math$Long_Long | null ) : number ;
    /**
     * Returns this Long divided by the given one.
     * @param other Long by which to divide.
     */
    div (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    equals (other : module$contents$goog$math$Long_Long | null ) : boolean ;
    getHighBits ( ) : number ;
    getLowBits ( ) : number ;
    getLowBitsUnsigned ( ) : number ;
    getNumBitsAbs ( ) : number ;
    greaterThan (other : module$contents$goog$math$Long_Long | null ) : boolean ;
    greaterThanOrEqual (other : module$contents$goog$math$Long_Long | null ) : boolean ;
    /**
     * Returns a hash code for this long object that similar java.lang.Long one.
     */
    hashCode ( ) : number ;
    isNegative ( ) : boolean ;
    isOdd ( ) : boolean ;
    isSafeInteger ( ) : boolean ;
    isZero ( ) : boolean ;
    lessThan (other : module$contents$goog$math$Long_Long | null ) : boolean ;
    lessThanOrEqual (other : module$contents$goog$math$Long_Long | null ) : boolean ;
    /**
     * Returns this Long modulo the given one.
     * @param other Long by which to mod.
     */
    modulo (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns the product of this and the given long.
     * @param other Long to multiply with this.
     */
    multiply (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    negate ( ) : module$contents$goog$math$Long_Long ;
    not ( ) : module$contents$goog$math$Long_Long ;
    notEquals (other : module$contents$goog$math$Long_Long | null ) : boolean ;
    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @param other The Long with which to OR.
     */
    or (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param numBits The number of bits by which to shift.
     */
    shiftLeft (numBits : number ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns this Long with bits shifted to the right by the given amount.
     * The new leading bits match the current sign bit.
     * @param numBits The number of bits by which to shift.
     */
    shiftRight (numBits : number ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * zeros placed into the new leading bits.
     * @param numBits The number of bits by which to shift.
     */
    shiftRightUnsigned (numBits : number ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns the difference of this and the given Long.
     * @param other Long to subtract from this.
     */
    subtract (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    toInt ( ) : number ;
    toNumber ( ) : number ;
    toString (opt_radix ? : number ) : string ;
    toUnsignedString (opt_radix ? : number ) : string ;
    /**
     * Returns the bitwise-XOR of this Long and the given one.
     * @param other The Long with which to XOR.
     */
    xor (other : module$contents$goog$math$Long_Long | null ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns a Long representing the 64-bit integer that comes by concatenating
     * the given high and low bits.  Each is assumed to use 32 bits.
     * @param lowBits The low 32-bits.
     * @param highBits The high 32-bits.
     */
    static fromBits (lowBits : number , highBits : number ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @param value The 32-bit integer in question.
     */
    static fromInt (value : number ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns a Long representing the given value.
     * NaN will be returned as zero. Infinity is converted to max value and
     * -Infinity to min value.
     * @param value The number in question.
     */
    static fromNumber (value : number ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns a Long representation of the given string, written using the given
     * radix.
     * @param str The textual representation of the Long.
     * @param opt_radix The radix in which the text is written.
     */
    static fromString (str : string , opt_radix ? : number ) : module$contents$goog$math$Long_Long ;
    static getMaxValue ( ) : module$contents$goog$math$Long_Long ;
    static getMinValue ( ) : module$contents$goog$math$Long_Long ;
    static getNegOne ( ) : module$contents$goog$math$Long_Long ;
    static getOne ( ) : module$contents$goog$math$Long_Long ;
    static getTwoPwr24 ( ) : module$contents$goog$math$Long_Long ;
    static getZero ( ) : module$contents$goog$math$Long_Long ;
    /**
     * Returns the boolean value of whether the input string is within a Long's
     * range. Assumes an input string containing only numeric characters with an
     * optional preceding '-'.
     * @param str The textual representation of the Long.
     * @param opt_radix The radix in which the text is written.
     */
    static isStringInRange (str : string , opt_radix ? : number ) : boolean ;
  }
}
declare namespace ಠ_ಠ.clutz {
  export import module$exports$goog$math$Long = ಠ_ಠ.clutz.module$contents$goog$math$Long_Long ;
}
