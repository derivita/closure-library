//!! generated by clutz.
// Generated from editor/node.js
declare namespace ಠ_ಠ.clutz.goog.editor.node {
  /**
   * Search ancestor nodes using a predicate function and returns the topmost
   * ancestor in the chain of consecutive ancestors that satisfies the condition.
   * @param node The node whose ancestors have to be searched.
   * @param hasProperty A function that takes a parent node as a parameter and returns true if it meets the criteria.
   */
  function findHighestMatchingAncestor (node : Node | null , hasProperty : (a : Node | null ) => boolean ) : Node | null ;
  /**
   * Search child nodes using a predicate function and return the first node that
   * satisfies the condition.
   * @param parent The parent node to search.
   * @param hasProperty A function that takes a child node as a parameter and returns true if it meets the criteria.
   */
  function findInChildren (parent : Node | null , hasProperty : (a : Node | null ) => boolean ) : number | null ;
  /**
   * Finds the top-most DOM node inside an editable field that is an ancestor
   * (or self) of a given DOM node and meets the specified criteria.
   * @param node The DOM node where the search starts.
   * @param criteria A function that takes a DOM node as a parameter and returns a boolean to indicate whether the node meets the criteria or not.
   */
  function findTopMostEditableAncestor (node : Node | null , criteria : (a : Node | null ) => boolean ) : Node | null ;
  /**
   * Version of firstChild that skips nodes that are entirely
   * whitespace and comments.
   * @param parent The reference node.
   */
  function getFirstChild (parent : Node | null ) : Node | null ;
  /**
   * Version of lastChild that skips nodes that are entirely whitespace or
   * comments.  (Normally lastChild is a property of all DOM nodes that gives the
   * last of the nodes contained directly in the reference node.)
   * @param parent The reference node.
   */
  function getLastChild (parent : Node | null ) : Node | null ;
  /**
   * Get the left-most non-ignorable leaf node of the given node.
   * @param parent The parent ndoe.
   */
  function getLeftMostLeaf (parent : Node | null ) : Node | null ;
  /**
   * Returns the length of the text in node if it is a text node, or the number
   * of children of the node, if it is an element. Useful for range-manipulation
   * code where you need to know the offset for the right side of the node.
   * @param node The node to get the length of.
   */
  function getLength (node : Node | null ) : number ;
  /**
   * Version of nextSibling that skips nodes that are entirely whitespace or
   * comments.
   * @param sibling The reference node.
   */
  function getNextSibling (sibling : Node | null ) : Node | null ;
  /**
   * Version of previoussibling that skips nodes that are entirely
   * whitespace or comments.  (Normally previousSibling is a property
   * of all DOM nodes that gives the sibling node, the node that is
   * a child of the same parent, that occurs immediately before the
   * reference node.)
   * @param sibling The reference node.
   */
  function getPreviousSibling (sibling : Node | null ) : Node | null ;
  /**
   * Get the right-most non-ignorable leaf node of the given node.
   * @param parent The parent ndoe.
   */
  function getRightMostLeaf (parent : Node | null ) : Node | null ;
  /**
   * Determine whether a node's text content is entirely whitespace.
   * @param textNode A node implementing the CharacterData interface (i.e., a Text, Comment, or CDATASection node.
   */
  function isAllNonNbspWhiteSpace (textNode : Node | null ) : boolean ;
  /**
   * Checks if node is a block-level html element. The <tt>display</tt> css
   * property is ignored.
   * @param node The node to test.
   */
  function isBlockTag (node : Node | null ) : boolean ;
  /**
   * Checks if a node is inside an editable container.
   * @param node The node to test.
   */
  function isEditable (node : Node | null ) : boolean ;
  /**
   * Checks if an element is a top-level editable container (meaning that
   * it itself is not editable, but all its child nodes are editable).
   * @param element The element to test.
   */
  function isEditableContainer (element : Node | null ) : boolean ;
  /**
   * Returns true if the node contains only whitespace and is not and does not
   * contain any images, iframes or embed tags.
   * @param node The node to check.
   * @param opt_prohibitSingleNbsp By default, this function treats a single nbsp as empty.  Set this to true to treat this case as non-empty.
   */
  function isEmpty (node : Node | null , opt_prohibitSingleNbsp ? : boolean ) : boolean ;
  /**
   * Determine if a node should be returned by the iterator functions.
   * @param node An object implementing the DOM1 Node interface.
   */
  function isImportant (node : Node | null ) : boolean ;
  /**
   * Check if the node is in a standards mode document.
   * @param node The node to test.
   */
  function isStandardsMode (node : Node | null ) : boolean ;
  /**
   * Replaces the innerHTML of a node.
   *
   * IE has serious problems if you try to set innerHTML of an editable node with
   * any selection. Early versions of IE tear up the old internal tree storage, to
   * help avoid ref-counting loops. But this sometimes leaves the selection object
   * in a bad state and leads to segfaults.
   *
   * Removing the nodes first prevents IE from tearing them up. This is not
   * strictly necessary in nodes that do not have the selection. You should always
   * use this function when setting innerHTML inside of a field.
   * @param node A node.
   * @param html The innerHTML to set on the node.
   */
  function replaceInnerHtml (node : Node | null , html : string ) : void ;
  /**
   * Skips siblings of a node that are empty text nodes.
   * @param node A node. May be null.
   */
  function skipEmptyTextNodes (node : Node | null ) : Node | null ;
  /**
   * Splits off a subtree.
   * @param currentNode The starting splitting point.
   * @param opt_secondHalf The initial leftmost leaf the new subtree. If null, siblings after currentNode will be placed in the subtree, but no additional node will be.
   * @param opt_root The top of the tree where splitting stops at.
   */
  function splitDomTreeAt (currentNode : Node , opt_secondHalf ? : Node | null , opt_root ? : Node | null ) : Node ;
  /**
   * Appends all of oldNode's children to newNode. This removes all children from
   * oldNode and appends them to newNode. oldNode is left with no children.
   * @param newNode Node to transfer children to.
   * @param oldNode Node to transfer children from.
   */
  function transferChildren (newNode : Node , oldNode : Node | null ) : void ;
}
declare module 'goog:goog.editor.node' {
  import node = ಠ_ಠ.clutz.goog.editor.node;
  export = node;
}
