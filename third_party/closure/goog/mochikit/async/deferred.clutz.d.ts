//!! generated by clutz.
// Generated from ../../third_party/closure/goog/mochikit/async/deferred.js
declare namespace ಠ_ಠ.clutz.goog.async {
  /**
   * A Deferred represents the result of an asynchronous operation. A Deferred
   * instance has no result when it is created, and is "fired" (given an initial
   * result) by calling `callback` or `errback`.
   *
   * Once fired, the result is passed through a sequence of callback functions
   * registered with `addCallback` or `addErrback`. The functions may
   * mutate the result before it is passed to the next function in the sequence.
   *
   * Callbacks and errbacks may be added at any time, including after the Deferred
   * has been "fired". If there are no pending actions in the execution sequence
   * of a fired Deferred, any new callback functions will be called with the last
   * computed result. Adding a callback function is the only way to access the
   * result of the Deferred.
   *
   * If a Deferred operation is canceled, an optional user-provided cancellation
   * function is invoked which may perform any special cleanup, followed by firing
   * the Deferred's errback sequence with a `CanceledError`. If the
   * Deferred has already fired, cancellation is ignored.
   *
   * Deferreds may be templated to a specific type they produce using generics
   * with syntax such as:
   *
   * /** @type {goog.async.Deferred<string>} *\
   * var d = new goog.async.Deferred();
   * // Compiler can infer that foo is a string.
   * d.addCallback(function(foo) {...});
   * d.callback('string');  // Checked to be passed a string
   *
   * Since deferreds are often used to produce different values across a chain,
   * the type information is not propagated across chains, but rather only
   * associated with specifically cast objects.
   */
  class Deferred < VALUE = any > implements ಠ_ಠ.clutz.goog.Thenable < VALUE > {
    private noStructuralTyping_goog_async_Deferred : any;
    /**
     * A Deferred represents the result of an asynchronous operation. A Deferred
     * instance has no result when it is created, and is "fired" (given an initial
     * result) by calling `callback` or `errback`.
     *
     * Once fired, the result is passed through a sequence of callback functions
     * registered with `addCallback` or `addErrback`. The functions may
     * mutate the result before it is passed to the next function in the sequence.
     *
     * Callbacks and errbacks may be added at any time, including after the Deferred
     * has been "fired". If there are no pending actions in the execution sequence
     * of a fired Deferred, any new callback functions will be called with the last
     * computed result. Adding a callback function is the only way to access the
     * result of the Deferred.
     *
     * If a Deferred operation is canceled, an optional user-provided cancellation
     * function is invoked which may perform any special cleanup, followed by firing
     * the Deferred's errback sequence with a `CanceledError`. If the
     * Deferred has already fired, cancellation is ignored.
     *
     * Deferreds may be templated to a specific type they produce using generics
     * with syntax such as:
     *
     * /** @type {goog.async.Deferred<string>} *\
     * var d = new goog.async.Deferred();
     * // Compiler can infer that foo is a string.
     * d.addCallback(function(foo) {...});
     * d.callback('string');  // Checked to be passed a string
     *
     * Since deferreds are often used to produce different values across a chain,
     * the type information is not propagated across chains, but rather only
     * associated with specifically cast objects.
     * @param opt_onCancelFunction A function that will be called if the Deferred is canceled. If provided, this function runs before the Deferred is fired with a `CanceledError`.
     * @param opt_defaultScope The default object context to call callbacks and errbacks in.
     */
    constructor (opt_onCancelFunction ? : Function | null , opt_defaultScope ? : GlobalObject | null ) ;
    /**
     * Registers one function as both a callback and errback.
     * @param f The function to be called on any result.
     * @param opt_scope An optional scope to call the function in.
     */
    addBoth < T = any > (f : (this : T , a ? : any ) => any , opt_scope ? : T ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Register a callback function to be called with a successful result. If no
     * value is returned by the callback function, the result value is unchanged. If
     * a new value is returned, it becomes the Deferred result and will be passed to
     * the next callback in the execution sequence.
     *
     * If the function throws an error, the error becomes the new result and will be
     * passed to the next errback in the execution chain.
     *
     * If the function returns a Deferred, the execution sequence will be blocked
     * until that Deferred fires. Its result will be passed to the next callback (or
     * errback if it is an error result) in this Deferred's execution sequence.
     * @param cb The function to be called with a successful result.
     * @param opt_scope An optional scope to call the callback in.
     */
    addCallback < T = any > (cb : (this : T , a : VALUE ) => any , opt_scope ? : T ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Registers a callback function and an errback function at the same position
     * in the execution sequence. Only one of these functions will execute,
     * depending on the error state during the execution sequence.
     *
     * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If
     * the callback is invoked, the errback will be skipped, and vice versa.
     * @param cb The function to be called on a successful result.
     * @param eb The function to be called on an unsuccessful result.
     * @param opt_scope An optional scope to call the functions in.
     */
    addCallbacks < T = any > (cb : ( (this : T , a : VALUE ) => any ) | null , eb : ( (this : T , a ? : any ) => any ) | null , opt_scope ? : T ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Register a callback function to be called with an error result. If no value
     * is returned by the function, the error result is unchanged. If a new error
     * value is returned or thrown, that error becomes the Deferred result and will
     * be passed to the next errback in the execution sequence.
     *
     * If the errback function handles the error by returning a non-error value,
     * that result will be passed to the next normal callback in the sequence.
     *
     * If the function returns a Deferred, the execution sequence will be blocked
     * until that Deferred fires. Its result will be passed to the next callback (or
     * errback if it is an error result) in this Deferred's execution sequence.
     * @param eb The function to be called on an unsuccessful result.
     * @param opt_scope An optional scope to call the errback in.
     */
    addErrback < T = any > (eb : (this : T , a ? : any ) => any , opt_scope ? : T ) : ಠ_ಠ.clutz.goog.async.Deferred < VALUE > ;
    /**
     * Like addBoth, but propagates uncaught exceptions in the errback.
     * @param f The function to be called on any result.
     * @param opt_scope An optional scope to call the function in.
     */
    addFinally < T = any > (f : (this : T , a ? : any ) => any , opt_scope ? : T ) : ಠ_ಠ.clutz.goog.async.Deferred < VALUE > ;
    /**
     * Makes this Deferred wait for another Deferred's execution sequence to
     * complete before continuing.
     *
     * This is equivalent to adding a callback that returns `otherDeferred`,
     * but doesn't prevent additional callbacks from being added to
     * `otherDeferred`.
     * @param otherDeferred The Deferred to wait for.
     */
    awaitDeferred (otherDeferred : ಠ_ಠ.clutz.goog.async.Deferred < any > | ಠ_ಠ.clutz.goog.Thenable ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Creates a branch off this Deferred's execution sequence, and returns it as a
     * new Deferred. The branched Deferred's starting result will be shared with the
     * parent at the point of the branch, even if further callbacks are added to the
     * parent.
     *
     * All branches at the same stage in the execution sequence will receive the
     * same starting value.
     * @param opt_propagateCancel If cancel() is called on every child branch created with opt_propagateCancel, the parent will be canceled as well.
     */
    branch (opt_propagateCancel ? : boolean ) : ಠ_ಠ.clutz.goog.async.Deferred < VALUE > ;
    /**
     * Fire the execution sequence for this Deferred by passing the starting result
     * to the first registered callback.
     * @param opt_result The starting result.
     */
    callback (opt_result ? : VALUE ) : void ;
    /**
     * Cancels a Deferred that has not yet been fired, or is blocked on another
     * deferred operation. If this Deferred is waiting for a blocking Deferred to
     * fire, the blocking Deferred will also be canceled.
     *
     * If this Deferred was created by calling branch() on a parent Deferred with
     * opt_propagateCancel set to true, the parent may also be canceled. If
     * opt_deepCancel is set, cancel() will be called on the parent (as well as any
     * other ancestors if the parent is also a branch). If one or more branches were
     * created with opt_propagateCancel set to true, the parent will be canceled if
     * cancel() is called on all of those branches.
     * @param opt_deepCancel If true, cancels this Deferred's parent even if cancel() hasn't been called on some of the parent's branches. Has no effect on a branch without opt_propagateCancel set to true.
     */
    cancel (opt_deepCancel ? : boolean ) : void ;
    /**
     * Links another Deferred to the end of this Deferred's execution sequence. The
     * result of this execution sequence will be passed as the starting result for
     * the chained Deferred, invoking either its first callback or errback.
     * @param otherDeferred The Deferred to chain.
     */
    chainDeferred (otherDeferred : ಠ_ಠ.clutz.goog.async.Deferred < any > ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Fire the execution sequence for this Deferred by passing the starting error
     * result to the first registered errback.
     * @param opt_result The starting error.
     */
    errback (opt_result ? : any ) : void ;
    /**
     * Return the most recent value fired.
     */
    getLastValueForMigration ( ) : VALUE | undefined ;
    hasFired ( ) : boolean ;
    protected isError (res : any ) : boolean ;
    /**
     * Implements {@see goog.Thenable} for seamless integration with
     * {@see goog.Promise}.
     * Deferred results are mutable and may represent multiple values over
     * their lifetime. Calling `then` on a Deferred returns a Promise
     * with the result of the Deferred at that point in its callback chain.
     * Note that if the Deferred result is never mutated, and only
     * `then` calls are made, the Deferred will behave like a Promise.
     */
    then < RESULT > (opt_onFulfilled ? : ( (a : VALUE ) => PromiseLike < RESULT > | RESULT ) | null , opt_onRejected ? : ( (a : any ) => any ) | null) : ಠ_ಠ.clutz.goog.async.Deferred < RESULT > ;
    static LONG_STACK_TRACES : boolean ;
    static STRICT_ERRORS : boolean ;
    static assertNoErrors ( ) : void ;
    /**
     * Creates a Deferred that has already been canceled.
     */
    static canceled ( ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Creates a Deferred that has an initial error result.
     * @param res The error result.
     */
    static fail (res : any ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Creates a Deferred that fires when the given promise resolves.
     * Use only during migration to Promises.
     *
     * Note: If the promise resolves to a thenable value (which is not allowed by
     * conforming promise implementations), then the deferred may behave
     * unexpectedly as it tries to wait on it. This should not be a risk when using
     * goog.Promise, goog.async.Deferred, or native Promise objects.
     */
    static fromPromise < T = any > (promise : PromiseLike < T > ) : ಠ_ಠ.clutz.goog.async.Deferred < T > ;
    static setUnhandledErrorHandler (handler : (a : any ) => any ) : void ;
    /**
     * Creates a Deferred that has an initial result.
     * @param opt_result The result.
     */
    static succeed (opt_result ? : any ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
    /**
     * Normalizes values that may or may not be Deferreds.
     *
     * If the input value is a Deferred, the Deferred is branched (so the original
     * execution sequence is not modified) and the input callback added to the new
     * branch. The branch is returned to the caller.
     *
     * If the input value is not a Deferred, the callback will be executed
     * immediately and an already firing Deferred will be returned to the caller.
     *
     * In the following (contrived) example, if <code>isImmediate</code> is true
     * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.
     *
     * <pre>
     * var value;
     * if (isImmediate) {
     * value = 3;
     * } else {
     * value = new goog.async.Deferred();
     * setTimeout(function() { value.callback(6); }, 2000);
     * }
     *
     * var d = goog.async.Deferred.when(value, alert);
     * </pre>
     * @param value Deferred or normal value to pass to the callback.
     * @param callback The callback to execute.
     * @param opt_scope An optional scope to call the callback in.
     */
    static when < T = any > (value : any , callback : (this : T , a ? : any ) => any , opt_scope ? : T ) : ಠ_ಠ.clutz.goog.async.Deferred < any > ;
  }
}
// Generated from ../../third_party/closure/goog/mochikit/async/deferred.js
declare namespace ಠ_ಠ.clutz.goog.async.Deferred {
  class Error_ {
    private noStructuralTyping_goog_async_Deferred_Error_ : any;
    resetTimer ( ) : void ;
    throwError ( ) : void ;
  }
}
declare module 'goog:goog.async.Deferred' {
  import Deferred = ಠ_ಠ.clutz.goog.async.Deferred;
  export default Deferred;
}
// Generated from ../../third_party/closure/goog/mochikit/async/deferred.js
declare namespace ಠ_ಠ.clutz.goog.async.Deferred {
  /**
   * An error sub class that is used when a Deferred has already been called.
   */
  class AlreadyCalledError extends ಠ_ಠ.clutz.goog.debug.Error {
    private noStructuralTyping_goog_async_Deferred_AlreadyCalledError : any;
    /**
     * An error sub class that is used when a Deferred has already been called.
     * @param deferred The Deferred.
     */
    constructor (deferred : ಠ_ಠ.clutz.goog.async.Deferred < any > ) ;
    /**
     * The Deferred that raised this error.
     */
    deferred : ಠ_ಠ.clutz.goog.async.Deferred < any > | null ;
    message : string ;
    name : string ;
  }
}
declare module 'goog:goog.async.Deferred.AlreadyCalledError' {
  import AlreadyCalledError = ಠ_ಠ.clutz.goog.async.Deferred.AlreadyCalledError;
  export default AlreadyCalledError;
}
// Generated from ../../third_party/closure/goog/mochikit/async/deferred.js
declare namespace ಠ_ಠ.clutz.goog.async.Deferred {
  /**
   * An error sub class that is used when a Deferred is canceled.
   */
  class CanceledError extends ಠ_ಠ.clutz.goog.debug.Error {
    private noStructuralTyping_goog_async_Deferred_CanceledError : any;
    /**
     * An error sub class that is used when a Deferred is canceled.
     * @param deferred The Deferred object.
     */
    constructor (deferred : ಠ_ಠ.clutz.goog.async.Deferred < any > ) ;
    /**
     * The Deferred that raised this error.
     */
    deferred : ಠ_ಠ.clutz.goog.async.Deferred < any > | null ;
    message : string ;
    name : string ;
  }
}
declare module 'goog:goog.async.Deferred.CanceledError' {
  import CanceledError = ಠ_ಠ.clutz.goog.async.Deferred.CanceledError;
  export default CanceledError;
}
